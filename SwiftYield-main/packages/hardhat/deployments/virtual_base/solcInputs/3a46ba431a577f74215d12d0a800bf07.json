{
  "language": "Solidity",
  "sources": {
    "contracts/FlashLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.0;\n\n// import {IVault} from \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\";\n// import {IFlashLoanRecipient} from \"@balancer-labs/v2-interfaces/contracts/vault/IFlashLoanRecipient.sol\";\n// import {IERC20} from \"@balancer-labs/v2-interfaces/contracts/solidity-utils/openzeppelin/IERC20.sol\";\n// import {IUniswapV2Router02} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\n\n// contract FlashLoanRecipient is IFlashLoanRecipient {\n//     address public owner = msg.sender;\n\n//     IVault private constant vault =\n//         IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n\n//     address private constant diaToken =\n//         0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb;\n//     uint256 private constant diaInput = 1000000000000000000; // 1 DAI Token\n\n//     address private constant wethToken =\n//         0x4200000000000000000000000000000000000006;\n\n//     // Deployments are on Base Mainnet\n\n//     IUniswapV2Router02 private constant uniswapRouter =\n//         IUniswapV2Router02(0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24);\n//     IUniswapV2Router02 private constant sushiswapRouter =\n//         IUniswapV2Router02(0x6BDED42c6DA8FBf0d2bA55B2fa120C5e0c8D7891);\n//     IUniswapV2Router02 private constant pancakeswapRouter =\n//         IUniswapV2Router02(0x8cFe327CEc66d1C090Dd72bd0FF11d690C33a2Eb);\n\n//     // add other routers\n\n//     function uniswapTokens(\n//         address _tokenIn,\n//         uint256 _amountIn,\n//         address _tokenOut,\n//         uint256 _amountOutMin\n//     ) public returns (uint256) {\n//         // require(msg.sender == owner, \"Only the owner can initiate swaps\");\n//         IERC20(_tokenIn).approve(address(uniswapRouter), _amountIn);\n\n//         address[] memory path = new address[](2);\n//         path[0] = _tokenIn;\n//         path[1] = _tokenOut;\n\n//         uint256[] memory prices = uniswapRouter.swapExactTokensForTokens(\n//             _amountIn,\n//             _amountOutMin,\n//             path,\n//             address(this),\n//             block.timestamp\n//         );\n//         return prices[1];\n//     }\n\n//     function sushiswapTokens(\n//         address _tokenIn,\n//         uint256 _amountIn,\n//         address _tokenOut,\n//         uint256 _amountOutMin\n//     ) public returns (uint256) {\n//         // require(msg.sender == owner, \"Only the owner can initiate swaps\");\n//         IERC20(_tokenIn).approve(address(sushiswapRouter), _amountIn);\n\n//         address[] memory path = new address[](2);\n//         path[0] = _tokenIn;\n//         path[1] = _tokenOut;\n\n//         uint256[] memory prices = sushiswapRouter.swapExactTokensForTokens(\n//             _amountIn,\n//             _amountOutMin,\n//             path,\n//             address(this),\n//             block.timestamp\n//         );\n//         return prices[1];\n//     }\n\n//     function pancakeswapTokens(\n//         address _tokenIn,\n//         uint256 _amountIn,\n//         address _tokenOut,\n//         uint256 _amountOutMin\n//     ) public returns (uint256) {\n//         // require(msg.sender == owner, \"Only the owner can initiate swaps\");\n//         IERC20(_tokenIn).approve(address(pancakeswapRouter), _amountIn);\n\n//         address[] memory path = new address[](2);\n//         path[0] = _tokenIn;\n//         path[1] = _tokenOut;\n\n//         uint256[] memory prices = pancakeswapRouter.swapExactTokensForTokens(\n//             _amountIn,\n//             _amountOutMin,\n//             path,\n//             address(this),\n//             block.timestamp\n//         );\n//         return prices[1];\n//     }\n\n//     function hello() public pure returns (string memory) {\n//         return string(\"Thank you so much\");\n//     }\n\n//     function makeFlashLoan(\n//         IERC20[] memory tokens,\n//         uint256[] memory amounts,\n//         bytes memory userData\n//     ) external {\n//         vault.flashLoan(this, tokens, amounts, userData);\n//     }\n\n//     function receiveFlashLoan(\n//         IERC20[] memory tokens,\n//         uint256[] memory amounts,\n//         uint256[] memory feeAmounts,\n//         bytes memory userData\n//     ) external override {\n//         require(msg.sender == address(vault));\n//         // This contract now has the funds requested.\n\n//         // 0x0101 -> uniswap // 0x0202 -> sushiswap // 0x0303 -> pancakeswap\n\n//         // if (userData[0] == 0x01) {\n//         // \tif (userData[1] == 0x02) {\n//         // \t\tuint256 uniswapReturns = uniswapTokens(\n//         // \t\t\tdiaToken,\n//         // \t\t\tdiaInput,\n//         // \t\t\twethToken,\n//         // \t\t\twethInput\n//         // \t\t);\n//         // \t\tsushiswapTokens(wethToken, uniswapReturns, diaToken, diaInput);\n//         // \t} else if (userData[1] == 0x03) {\n//         // \t\tuint256 uniswapReturns = uniswapTokens(\n//         // \t\t\tdiaToken,\n//         // \t\t\tdiaInput,\n//         // \t\t\twethToken,\n//         // \t\t\twethInput\n//         // \t\t);\n//         // \t\tpancakeswapTokens(\n//         // \t\t\twethToken,\n//         // \t\t\tuniswapReturns,\n//         // \t\t\tdiaToken,\n//         // \t\t\tdiaInput\n//         // \t\t);\n//         // \t}\n//         // } else if (userData[0] == 0x02) {\n//         // \tif (userData[1] == 0x01) {\n//         // \t\tuint256 sushiswapReturns = sushiswapTokens(\n//         // \t\t\tdiaToken,\n//         // \t\t\tdiaInput,\n//         // \t\t\twethToken,\n//         // \t\t\twethInput\n//         // \t\t);\n//         // \t\tuniswapTokens(wethToken, sushiswapReturns, diaToken, diaInput);\n//         // \t} else if (userData[1] == 0x03) {\n//         // \t\tuint256 sushiswapReturns = sushiswapTokens(\n//         // \t\t\tdiaToken,\n//         // \t\t\tdiaInput,\n//         // \t\t\twethToken,\n//         // \t\t\twethInput\n//         // \t\t);\n//         // \t\tpancakeswapTokens(\n//         // \t\t\twethToken,\n//         // \t\t\tsushiswapReturns,\n//         // \t\t\tdiaToken,\n//         // \t\t\tdiaInput\n//         // \t\t);\n//         // \t}\n//         // } else if (userData[0] == 0x03) {\n//         // \tif (userData[1] == 0x01) {\n//         // \t\tuint256 pancakeReturns = pancakeswapTokens(\n//         // \t\t\tdiaToken,\n//         // \t\t\tdiaInput,\n//         // \t\t\twethToken,\n//         // \t\t\twethInput\n//         // \t\t);\n//         // \t\tuniswapTokens(wethToken, pancakeReturns, diaToken, diaInput);\n//         // \t} else if (userData[1] == 0x02) {\n//         // \t\tuint256 pancakeReturns = pancakeswapTokens(\n//         // \t\t\tdiaToken,\n//         // \t\t\tdiaInput,\n//         // \t\t\twethToken,\n//         // \t\t\twethInput\n//         // \t\t);\n//         // \t\tsushiswapTokens(wethToken, pancakeReturns, diaToken, diaInput);\n//         // \t}\n//         // }\n\n//         // At the end of your logic above, this contract owes the flashloaned amounts + feeAmounts. Therefore ensure your contract has enough to repay these amounts.\n\n//         // Return loan\n//         for (uint256 i = 0; i < tokens.length; i++) {\n//             tokens[i].transfer(address(vault), amounts[i] + feeAmounts[i]);\n//         }\n//     }\n\n//     function swap( bytes memory userData) public {\n//         bytes memory swapAddress = new bytes(20);\n\n//         for (uint256 i = 0; i < 22; i++) {\n//             swapAddress[i] = userData[i + 2];\n//         }\n\n//         address swapTokenAddress = abi.decode(swapAddress, (address));\n\n//         // here this should be calculated properly like this should be in no of bytes that amount is equal to \n//         // not the number of numbers, if its a odd number pad a zero in the beginning\n//         uint8 token1AmountLength = uint8(userData[23]); \n//         uint8 token2AmountLength = uint8(userData[24]);\n\n//         bytes memory token1Amount = new bytes(token1AmountLength);\n//         bytes memory token2Amount = new bytes(token2AmountLength);        \n        \n//         uint j = 0;\n\n//         for (uint i = (userData.length - token2AmountLength + 1); i <= userData.length ; i++) \n//         {\n//             token1Amount[j] = userData[i];\n//             j++;\n//         }\n\n//         uint k = 0;\n\n//         for (uint i = (userData.length - token2AmountLength - token1AmountLength + 1); i <= (userData.length - token2AmountLength); i++) \n//         {\n//             token2Amount[k] = userData[i];\n//             k++;\n//         }\n\n//         uint256 token1AmountExpect = abi.decode(token1Amount, (uint256));\n//         uint256 token2AmountExpect = abi.decode(token2Amount, (uint256));\n\n//         if (userData[0] == 0x01) {\n//             if (userData[1] == 0x02) {\n//                 uint256 uniswapReturns = uniswapTokens( diaToken, diaInput, swapTokenAddress, token1AmountExpect);\n//                 sushiswapTokens(swapTokenAddress, uniswapReturns, diaToken, token2AmountExpect);\n//             } else if (userData[1] == 0x03) {\n//                 uint256 uniswapReturns = uniswapTokens( diaToken, diaInput, swapTokenAddress, token1AmountExpect);\n//                 pancakeswapTokens(swapTokenAddress, uniswapReturns, diaToken, token2AmountExpect);\n//             }\n//         } else if (userData[0] == 0x02) {\n//             if (userData[1] == 0x01) {\n//                 uint256 sushiswapReturns = sushiswapTokens( diaToken, diaInput, swapTokenAddress, token1AmountExpect );\n//                 uniswapTokens(swapTokenAddress, sushiswapReturns, diaToken, token2AmountExpect);\n//             } else if (userData[1] == 0x03) {\n//                 uint256 sushiswapReturns = sushiswapTokens( diaToken, diaInput, swapTokenAddress, token1AmountExpect );\n//                 pancakeswapTokens( swapTokenAddress, sushiswapReturns, diaToken, token2AmountExpect );\n//             }\n//         } else if (userData[0] == 0x03) {\n//             if (userData[1] == 0x01) {\n//                 uint256 pancakeReturns = pancakeswapTokens( diaToken, diaInput, swapTokenAddress, token1AmountExpect );\n//                 uniswapTokens(swapTokenAddress, pancakeReturns, diaToken, token2AmountExpect);\n//             } else if (userData[1] == 0x02) {\n//                 uint256 pancakeReturns = pancakeswapTokens( diaToken, diaInput, swapTokenAddress, token1AmountExpect );\n//                 sushiswapTokens(swapTokenAddress, pancakeReturns, diaToken, token2AmountExpect);\n//             }\n//         }\n//     }\n\n//     // function withdraw(params) {\n//     //     code\n//     // }\n\n//     // To determine the First exchange where\n//     // 0x01 -> uniswap\n//     // 0x02 -> sushiswap\n//     // 0x03 -> pancakeswap\n\n//     // To determine the Second exchange where\n//     // 0x0101 -> uniswap\n//     // 0x0202 -> sushiswap\n//     // 0x0303 -> pancakeswap\n\n//     // 0x01024200000000000000000000000000000000000006 -> Next 20 bytes/40 Hex characters is token out address\n\n//     // 0x01024200000000000000000000000000000000000006 Till here 22 bytes will be over\n\n//     // Now from 23 bytes upto data.length\n\n//     // 0x0102420000000000000000000000000000000000000613 -> 1st conversion rate length 23th byte\n\n//     // 0x010242000000000000000000000000000000000000061314 -> 2nd conversion rate length 24th byte\n\n//     // 0x0102420000000000000000000000000000000000000613143250000000 -> 1st conversion rate\n\n//     // 0x01024200000000000000000000000000000000000006131432500000004567900000000000000000 -> 2nd conversion rate\n// }\n\npragma solidity >=0.8.0 <0.9.0;\n  \ncontract FlashLoanRecipient { \n    // bytes4 public number; \n  \n    // constructor() { \n    //     number = 0x12345678; \n    // } \n  \n    // function getIndividualBytes() public view returns (bytes1, bytes1, bytes1, bytes1) { \n    //     bytes1 byte1 = bytes1(number[0]); \n    //     bytes1 byte2 = bytes1(number[1]); \n    //     bytes1 byte3 = bytes1(number[2]); \n    //     bytes1 byte4 = bytes1(number[3]); \n  \n    //     return (byte1, byte2, byte3, byte4); \n    // }\n\n    // function extractFirst20Bytes(bytes memory data) public pure  returns (int) {\n    //     // require(data.length >= 20, \"Input data is less than 20 bytes\");\n\n    //     // // Create a new bytes array to store the first 20 bytes\n    //     // bytes memory first20Bytes = new bytes(20);\n\n    //     // for (uint i = 0; i < 20; i++) {\n    //     //     first20Bytes[i] = data[i];\n    //     // }\n\n    //     // To determine the First exchange where \n    //     // 0x01 -> uniswap\n    //     // 0x02 -> sushiswap\n    //     // 0x03 -> pancakeswap\n\n    //     // To determine the Second exchange where \n    //     // 0x0101 -> uniswap\n    //     // 0x0202 -> sushiswap\n    //     // 0x0303 -> pancakeswap\n\n    //     // 0x01024200000000000000000000000000000000000006 -> Next 20 bytes/40 Hex characters is token out address \n\n    //     // 0x01024200000000000000000000000000000000000006 Till here 22 bytes will be over\n\n    //     // Now from 23 bytes upto data.length   \n        \n    //     // 0x0102420000000000000000000000000000000000000613 -> 1st conversion rate length\n\n    //     // 0x010242000000000000000000000000000000000000061314 -> 2nd conversion rate length\n\n    //     // 0x0102420000000000000000000000000000000000000613143250000000 -> 1st conversion rate\n\n    //     // 0x01024200000000000000000000000000000000000006131432500000004567900000000000000000 -> 2nd conversion rate\n\n    //     uint diff = data.length - 22;\n\n    //     bytes memory tokenAmountOut = new bytes(diff);\n\n    //     int test = 0;\n\n    //     for (uint i = 0; i < diff; i++) \n    //     {\n    //         test++;\n    //     }\n\n        \n    //     // function hello(uint a, uint b)  {\n    //     //     return a + b;\n    //     // }\n\n    //     // if (data[0] == 0x01){\n    //     //     return 0x05;\n    //     // } else {\n    //     //     return 0x06;\n    //     // }\n\n    //     return test;\n    //     // return data[1];\n    // }\n\n    uint public  hello;\n\n    function swap( bytes memory userData) public pure returns (uint[2] memory) {\n        bytes memory swapAddress = new bytes(20);\n\n        for (uint256 i = 0; i < 22; i++) {\n            swapAddress[i] = userData[i + 2];\n        }\n\n        address swapTokenAddress = abi.decode(swapAddress, (address));\n\n        // here this should be calculated properly like this should be in no of bytes that amount is equal to \n        // not the number of numbers, if its a odd number pad a zero in the beginning\n        uint8 token1AmountLength = uint8(userData[23]); \n        uint8 token2AmountLength = uint8(userData[24]);\n\n        bytes memory token1Amount = new bytes(token1AmountLength);\n        bytes memory token2Amount = new bytes(token2AmountLength);        \n        \n        uint j = 0;\n\n        for (uint i = (userData.length - token2AmountLength + 1); i <= userData.length ; i++) \n        {\n            token1Amount[j] = userData[i];\n            j++;\n        }\n\n        uint k = 0;\n\n        for (uint i = (userData.length - token2AmountLength - token1AmountLength + 1); i <= (userData.length - token2AmountLength); i++) \n        {\n            token2Amount[k] = userData[i];\n            k++;\n        }\n\n        uint256 token1AmountExpect = abi.decode(token1Amount, (uint256));\n        uint256 token2AmountExpect = abi.decode(token2Amount, (uint256));\n\n        return [token1AmountExpect, token2AmountExpect];\n\n        // if (userData[0] == 0x01) {\n        //     if (userData[1] == 0x02) {\n        //         uint256 uniswapReturns = uniswapTokens( diaToken, diaInput, swapTokenAddress, token1AmountExpect);\n        //         sushiswapTokens(swapTokenAddress, uniswapReturns, diaToken, token2AmountExpect);\n        //     } else if (userData[1] == 0x03) {\n        //         uint256 uniswapReturns = uniswapTokens( diaToken, diaInput, swapTokenAddress, token1AmountExpect);\n        //         pancakeswapTokens(swapTokenAddress, uniswapReturns, diaToken, token2AmountExpect);\n        //     }\n        // } else if (userData[0] == 0x02) {\n        //     if (userData[1] == 0x01) {\n        //         uint256 sushiswapReturns = sushiswapTokens( diaToken, diaInput, swapTokenAddress, token1AmountExpect );\n        //         uniswapTokens(swapTokenAddress, sushiswapReturns, diaToken, token2AmountExpect);\n        //     } else if (userData[1] == 0x03) {\n        //         uint256 sushiswapReturns = sushiswapTokens( diaToken, diaInput, swapTokenAddress, token1AmountExpect );\n        //         pancakeswapTokens( swapTokenAddress, sushiswapReturns, diaToken, token2AmountExpect );\n        //     }\n        // } else if (userData[0] == 0x03) {\n        //     if (userData[1] == 0x01) {\n        //         uint256 pancakeReturns = pancakeswapTokens( diaToken, diaInput, swapTokenAddress, token1AmountExpect );\n        //         uniswapTokens(swapTokenAddress, pancakeReturns, diaToken, token2AmountExpect);\n        //     } else if (userData[1] == 0x02) {\n        //         uint256 pancakeReturns = pancakeswapTokens( diaToken, diaInput, swapTokenAddress, token1AmountExpect );\n        //         sushiswapTokens(swapTokenAddress, pancakeReturns, diaToken, token2AmountExpect);\n        //     }\n        // }\n    }\n\n} \n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}